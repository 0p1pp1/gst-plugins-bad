<MACRO>
<NAME>GST_TYPE_DFBVIDEOSINK</NAME>
#define GST_TYPE_DFBVIDEOSINK              (gst_dfbvideosink_get_type())
</MACRO>
<MACRO>
<NAME>GST_DFBVIDEOSINK</NAME>
#define GST_DFBVIDEOSINK(obj)              (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_DFBVIDEOSINK, GstDfbVideoSink))
</MACRO>
<MACRO>
<NAME>GST_DFBVIDEOSINK_CLASS</NAME>
#define GST_DFBVIDEOSINK_CLASS(klass)      (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_DFBVIDEOSINK, GstDfbVideoSink))
</MACRO>
<MACRO>
<NAME>GST_IS_DFBVIDEOSINK</NAME>
#define GST_IS_DFBVIDEOSINK(obj)           (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_DFBVIDEOSINK))
</MACRO>
<MACRO>
<NAME>GST_IS_DFBVIDEOSINK_CLASS</NAME>
#define GST_IS_DFBVIDEOSINK_CLASS(obj)     (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_DFBVIDEOSINK))
</MACRO>
<STRUCT>
<NAME>GstDfbVideoSink</NAME>
</STRUCT>
<STRUCT>
<NAME>GstDfbVideoSinkClass</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_DFBSURFACE</NAME>
#define GST_TYPE_DFBSURFACE (gst_dfbsurface_get_type())
</MACRO>
<MACRO>
<NAME>GST_IS_DFBSURFACE</NAME>
#define GST_IS_DFBSURFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_DFBSURFACE))
</MACRO>
<MACRO>
<NAME>GST_DFBSURFACE</NAME>
#define GST_DFBSURFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_DFBSURFACE, GstDfbSurface))
</MACRO>
<STRUCT>
<NAME>GstDfbSurface</NAME>
</STRUCT>
<STRUCT>
<NAME>GstDfbSurface</NAME>
struct _GstDfbSurface {
  GstBuffer buffer; /* We extend GstBuffer */
  
  IDirectFBSurface *surface;
  
  gint width;
  gint height;
  
  gboolean locked;
  
  DFBSurfacePixelFormat pixel_format;
  
  GstDfbVideoSink *dfbvideosink;
};
</STRUCT>
<STRUCT>
<NAME>GstDfbVMode</NAME>
</STRUCT>
<STRUCT>
<NAME>GstDfbVMode</NAME>
struct _GstDfbVMode {
  gint width;
  gint height;
  gint bpp;
};
</STRUCT>
<STRUCT>
<NAME>GstDfbVideoSink</NAME>
struct _GstDfbVideoSink {
  /* Our element stuff */
  GstVideoSink videosink;
  
  GMutex *pool_lock;
  GSList *buffer_pool;
  
  /* Framerate numerator and denominator */
  gint fps_n;
  gint fps_d;
  
  gint video_width, video_height; /* size of incoming video */
  gint out_width, out_height;
  
  /* Standalone */
  IDirectFB *dfb;
  
  GSList *vmodes; /* Video modes */
  
  gint layer_id;
  IDirectFBDisplayLayer *layer;
  IDirectFBSurface *primary;
  IDirectFBEventBuffer *event_buffer;
  GThread *event_thread;
  
  /* Embedded */
  IDirectFBSurface *ext_surface;
  
  DFBSurfacePixelFormat pixel_format;
  
  gboolean hw_scaling;
  gboolean backbuffer;
  gboolean vsync;
  gboolean setup;
  gboolean running;
  
  /* Color balance */
  GList *cb_channels;
  gint brightness;
  gint contrast;
  gint hue;
  gint saturation;
  gboolean cb_changed;
  
  /* object-set pixel aspect ratio */
  GValue *par;
};
</STRUCT>
<STRUCT>
<NAME>GstDfbVideoSinkClass</NAME>
struct _GstDfbVideoSinkClass {
  GstVideoSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dfbvideosink_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_dfbsurface_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_XIMAGESRC</NAME>
#define GST_TYPE_XIMAGESRC (gst_ximagesrc_get_type())
</MACRO>
<MACRO>
<NAME>GST_XIMAGESRC</NAME>
#define GST_XIMAGESRC(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_XIMAGESRC,GstXImageSrc))
</MACRO>
<MACRO>
<NAME>GST_XIMAGESRC_CLASS</NAME>
#define GST_XIMAGESRC_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_XIMAGESRC,GstXImageSrc))
</MACRO>
<MACRO>
<NAME>GST_IS_XIMAGESRC</NAME>
#define GST_IS_XIMAGESRC(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_XIMAGESRC))
</MACRO>
<MACRO>
<NAME>GST_IS_XIMAGESRC_CLASS</NAME>
#define GST_IS_XIMAGESRC_CLASS(obj) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_XIMAGESRC))
</MACRO>
<STRUCT>
<NAME>GstXImageSrc</NAME>
</STRUCT>
<STRUCT>
<NAME>GstXImageSrcClass</NAME>
</STRUCT>
<FUNCTION>
<NAME>gst_ximagesrc_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstXImageSrc</NAME>
struct _GstXImageSrc
{
  GstPushSrc parent;

  /* Information on display */
  GstXContext *xcontext;
  gint width;
  gint height;
  
  Window xwindow;
  gchar *display_name;
  guint screen_num;
  
  /* Desired output framerate */
  gint fps_n;
  gint fps_d;
  
  /* for framerate sync */
  GstClockID clock_id; 
  gint64 last_frame_no;
  
  /* Protect X Windows calls */
  GMutex *x_lock;

  /* Gathered pool of emitted buffers */
  GMutex *pool_lock;
  GSList *buffer_pool;

  /* XFixes and XDamage support */
  gboolean have_xfixes;
  gboolean have_xdamage;
  gboolean show_pointer;
#ifdef HAVE_XFIXES
  int fixes_event_base;
  XFixesCursorImage *cursor_image;

#endif
#ifdef HAVE_XDAMAGE
  Damage damage;
  int damage_event_base;
  XserverRegion damage_region;
  GC damage_copy_gc;
#endif

};
</STRUCT>
<STRUCT>
<NAME>GstXImageSrcClass</NAME>
struct _GstXImageSrcClass
{
  GstPushSrcClass parent_class;
};
</STRUCT>
<STRUCT>
<NAME>GstTagLibMuxPriv</NAME>
</STRUCT>
<STRUCT>
<NAME>GstTagLibMux</NAME>
typedef struct _GstTagLibMux {
  GstElement    element;

  GstPad       *srcpad;
  GstPad       *sinkpad;
  GstTagList   *event_tags; /* tags received from upstream elements */
  gsize         tag_size;
  gboolean      render_tag;

  GstEvent     *newsegment_ev; /* cached newsegment event from upstream */
} GstTagLibMux;
</STRUCT>
<STRUCT>
<NAME>GstTagLibMuxClass</NAME>
typedef struct _GstTagLibMuxClass {
  GstElementClass parent_class;
} GstTagLibMuxClass;
</STRUCT>
<MACRO>
<NAME>GST_TYPE_TAG_LIB_MUX</NAME>
#define GST_TYPE_TAG_LIB_MUX \
  (gst_tag_lib_mux_get_type())
</MACRO>
<MACRO>
<NAME>GST_TAG_LIB_MUX</NAME>
#define GST_TAG_LIB_MUX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_TAG_LIB_MUX,GstTagLibMux))
</MACRO>
<MACRO>
<NAME>GST_TAG_LIB_MUX_CLASS</NAME>
#define GST_TAG_LIB_MUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_TAG_LIB_MUX,GstTagLibMuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_TAG_LIB_MUX</NAME>
#define GST_IS_TAG_LIB_MUX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_TAG_LIB_MUX))
</MACRO>
<MACRO>
<NAME>GST_IS_TAG_LIB_MUX_CLASS</NAME>
#define GST_IS_TAG_LIB_MUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_TAG_LIB_MUX))
</MACRO>
<FUNCTION>
<NAME>gst_tag_lib_mux_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
