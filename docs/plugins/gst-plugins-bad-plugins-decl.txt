<MACRO>
<NAME>GST_TYPE_DFBVIDEOSINK</NAME>
#define GST_TYPE_DFBVIDEOSINK              (gst_dfbvideosink_get_type())
</MACRO>
<MACRO>
<NAME>GST_DFBVIDEOSINK</NAME>
#define GST_DFBVIDEOSINK(obj)              (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_DFBVIDEOSINK, GstDfbVideoSink))
</MACRO>
<MACRO>
<NAME>GST_DFBVIDEOSINK_CLASS</NAME>
#define GST_DFBVIDEOSINK_CLASS(klass)      (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_DFBVIDEOSINK, GstDfbVideoSink))
</MACRO>
<MACRO>
<NAME>GST_IS_DFBVIDEOSINK</NAME>
#define GST_IS_DFBVIDEOSINK(obj)           (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_DFBVIDEOSINK))
</MACRO>
<MACRO>
<NAME>GST_IS_DFBVIDEOSINK_CLASS</NAME>
#define GST_IS_DFBVIDEOSINK_CLASS(obj)     (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_DFBVIDEOSINK))
</MACRO>
<STRUCT>
<NAME>GstDfbVideoSink</NAME>
</STRUCT>
<STRUCT>
<NAME>GstDfbVideoSinkClass</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_DFBSURFACE</NAME>
#define GST_TYPE_DFBSURFACE (gst_dfbsurface_get_type())
</MACRO>
<MACRO>
<NAME>GST_IS_DFBSURFACE</NAME>
#define GST_IS_DFBSURFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_DFBSURFACE))
</MACRO>
<MACRO>
<NAME>GST_DFBSURFACE</NAME>
#define GST_DFBSURFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_DFBSURFACE, GstDfbSurface))
</MACRO>
<STRUCT>
<NAME>GstDfbSurface</NAME>
</STRUCT>
<STRUCT>
<NAME>GstDfbSurface</NAME>
struct _GstDfbSurface {
  GstBuffer buffer; /* We extend GstBuffer */
  
  IDirectFBSurface *surface;
  
  gint width;
  gint height;
  
  gboolean locked;
  
  DFBSurfacePixelFormat pixel_format;
  
  GstDfbVideoSink *dfbvideosink;
};
</STRUCT>
<STRUCT>
<NAME>GstDfbVMode</NAME>
</STRUCT>
<STRUCT>
<NAME>GstDfbVMode</NAME>
struct _GstDfbVMode {
  gint width;
  gint height;
  gint bpp;
};
</STRUCT>
<STRUCT>
<NAME>GstDfbVideoSink</NAME>
struct _GstDfbVideoSink {
  /* Our element stuff */
  GstVideoSink videosink;
  
  GMutex *pool_lock;
  GSList *buffer_pool;
  
  /* Framerate numerator and denominator */
  gint fps_n;
  gint fps_d;
  
  gint video_width, video_height; /* size of incoming video */
  gint out_width, out_height;
  
  /* Standalone */
  IDirectFB *dfb;
  
  GSList *vmodes; /* Video modes */
  
  gint layer_id;
  IDirectFBDisplayLayer *layer;
  IDirectFBSurface *primary;
  IDirectFBEventBuffer *event_buffer;
  GThread *event_thread;
  
  /* Embedded */
  IDirectFBSurface *ext_surface;
  
  DFBSurfacePixelFormat pixel_format;
  
  gboolean hw_scaling;
  gboolean backbuffer;
  gboolean vsync;
  gboolean setup;
  gboolean running;
  
  /* Color balance */
  GList *cb_channels;
  gint brightness;
  gint contrast;
  gint hue;
  gint saturation;
  gboolean cb_changed;
  
  /* object-set pixel aspect ratio */
  GValue *par;
};
</STRUCT>
<STRUCT>
<NAME>GstDfbVideoSinkClass</NAME>
struct _GstDfbVideoSinkClass {
  GstVideoSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dfbvideosink_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_dfbsurface_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstId3v2Mux</NAME>
</STRUCT>
<STRUCT>
<NAME>GstId3v2MuxClass</NAME>
</STRUCT>
<STRUCT>
<NAME></NAME>
typedef struct _GstId3v2Mux {
  GstTagLibMux  taglibmux;
};
</STRUCT>
<STRUCT>
<NAME></NAME>
typedef struct _GstId3v2MuxClass {
  GstTagLibMuxClass  taglibmux_class;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_ID3V2_MUX</NAME>
#define GST_TYPE_ID3V2_MUX \
  (gst_id3v2_mux_get_type())
</MACRO>
<MACRO>
<NAME>GST_ID3V2_MUX</NAME>
#define GST_ID3V2_MUX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ID3V2_MUX,GstId3v2Mux))
</MACRO>
<MACRO>
<NAME>GST_ID3V2_MUX_CLASS</NAME>
#define GST_ID3V2_MUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_ID3V2_MUX,GstId3v2MuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_ID3V2_MUX</NAME>
#define GST_IS_ID3V2_MUX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ID3V2_MUX))
</MACRO>
<MACRO>
<NAME>GST_IS_ID3V2_MUX_CLASS</NAME>
#define GST_IS_ID3V2_MUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_ID3V2_MUX))
</MACRO>
<FUNCTION>
<NAME>gst_id3v2_mux_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstTagLibMux</NAME>
</STRUCT>
<STRUCT>
<NAME>GstTagLibMuxClass</NAME>
</STRUCT>
<STRUCT>
<NAME></NAME>
typedef struct _GstTagLibMux {
  GstElement    element;

  GstPad       *srcpad;
  GstPad       *sinkpad;
  GstTagList   *event_tags; /* tags received from upstream elements */
  gsize         tag_size;
  gboolean      render_tag;

  GstEvent     *newsegment_ev; /* cached newsegment event from upstream */
};
</STRUCT>
<STRUCT>
<NAME></NAME>
typedef struct _GstTagLibMuxClass {
  GstElementClass parent_class;

  /* vfuncs */
  GstBuffer  * (*render_tag) (GstTagLibMux * mux, GstTagList * tag_list);
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_TAG_LIB_MUX</NAME>
#define GST_TYPE_TAG_LIB_MUX \
  (gst_tag_lib_mux_get_type())
</MACRO>
<MACRO>
<NAME>GST_TAG_LIB_MUX</NAME>
#define GST_TAG_LIB_MUX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_TAG_LIB_MUX,GstTagLibMux))
</MACRO>
<MACRO>
<NAME>GST_TAG_LIB_MUX_CLASS</NAME>
#define GST_TAG_LIB_MUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_TAG_LIB_MUX,GstTagLibMuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_TAG_LIB_MUX</NAME>
#define GST_IS_TAG_LIB_MUX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_TAG_LIB_MUX))
</MACRO>
<MACRO>
<NAME>GST_IS_TAG_LIB_MUX_CLASS</NAME>
#define GST_IS_TAG_LIB_MUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_TAG_LIB_MUX))
</MACRO>
<FUNCTION>
<NAME>gst_tag_lib_mux_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
