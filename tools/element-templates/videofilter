/* vim: set filetype=c: */
% ClassName
GstVideoFilter
% TYPE_CLASS_NAME
GST_TYPE_VIDEO_FILTER
% pads
srcpad-template-video
sinkpad-template-video
% pkg-config
gstreamer-video-1.0
% includes
#include <gst/video/video.h>
#include <gst/video/gstvideofilter.h>
% prototypes
static gboolean gst_replace_set_info (GstVideoFilter * filter, GstCaps * incaps,
    GstVideoInfo * in_info, GstCaps * outcaps, GstVideoInfo * out_info);
static GstFlowReturn gst_replace_transform_frame (GstVideoFilter * filter,
    GstVideoFrame * inframe, GstVideoFrame * outframe);
static GstFlowReturn gst_replace_transform_frame_ip (GstVideoFilter * filter,
    GstVideoFrame * frame);
% declare-class
  GstVideoFilterClass *video_filter_class = GST_VIDEO_FILTER_CLASS (klass);
% set-methods
  video_filter_class->set_info = GST_DEBUG_FUNCPTR (gst_replace_set_info);
  video_filter_class->transform_frame = GST_DEBUG_FUNCPTR (gst_replace_transform_frame);
  video_filter_class->transform_frame_ip = GST_DEBUG_FUNCPTR (gst_replace_transform_frame_ip);
% methods
static gboolean
gst_replace_set_info (GstVideoFilter * filter, GstCaps * incaps,
    GstVideoInfo * in_info, GstCaps * outcaps, GstVideoInfo * out_info)
{
  GstReplace *replace = GST_REPLACE (filter);

  GST_DEBUG_OBJECT (replace, "set_info");

  return TRUE;
}

/* transform */
static GstFlowReturn
gst_replace_transform_frame (GstVideoFilter * filter, GstVideoFrame * inframe,
    GstVideoFrame * outframe)
{
  GstReplace *replace = GST_REPLACE (filter);

  GST_DEBUG_OBJECT (replace, "transform_frame");

  return GST_FLOW_OK;
}

static GstFlowReturn
gst_replace_transform_frame_ip (GstVideoFilter * filter, GstVideoFrame * frame)
{
  GstReplace *replace = GST_REPLACE (filter);

  GST_DEBUG_OBJECT (replace, "transform_frame_ip");

  return GST_FLOW_OK;
}
% end
