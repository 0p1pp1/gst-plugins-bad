/* -*- C -*- */

_TYPE_ *data_in, *data_out, *filter_data;

filter_data = (_TYPE_ *) filter->buffer;
num_filter = filter->buffer_size / sizeof(_TYPE_);
max_filter = (filter->play_from_beginning) ? num_filter : G_MAXUINT;

/******************************************************************************/
/* see if we've got any events coming through ... */

do {
  GST_DEBUG(0, "--- going to events");

  while (! filter->eos && GST_IS_EVENT(in)) {
    if (GST_EVENT_TYPE(in) == GST_EVENT_EOS) {
      filter->eos = TRUE;
    } else {
      gst_pad_push(filter->srcpad, in);
    }

    in = gst_pad_pull(filter->sinkpad);
  }

  /****************************************************************************/
  /* first handle data from the input buffer. */

  GST_DEBUG(0, "--- done with events, going to input");

  /* only update the input if there hasn't been an eos yet. */
  if (! filter->eos) {
    data_in = (_TYPE_ *) GST_BUFFER_DATA(in);
    num_in = GST_BUFFER_SIZE(in) / sizeof(_TYPE_);

    w = filter->write;

    /* copy the input data to the filter's internal buffer. */
    for (j = 0; (j < num_in) && ((w + j) < max_filter); j++) {
      filter_data[(w + j) % num_filter] = data_in[j];
    }

    filter->write = (w + j) % num_filter;

    if ((w + j) >= num_filter) {
      filter->buffer_filled_once = TRUE;

      /* if we're not playing from the end of the stream, the buffer is not a
         ring buffer, so it has a fixed size. we need to set eos here because
         we've passed that limit. */
      if (filter->play_from_beginning) {
        filter->eos = TRUE;
      }
    }

    /* update the start pointer */
    if ((! filter->play_from_beginning) && filter->buffer_filled_once) {
      filter->start = (filter->write + 1) % num_filter;
    }

    out = in;
  } else {
    j = num_filter;
    w = 0;

    out = gst_buffer_new_from_pool(filter->bufpool, 0, 0);
  }

  /****************************************************************************/
  /* check to see if we have to add a new play pointer. */

  GST_DEBUG(0, "--- done with input, checking clock before output");

  play_on_demand_update_plays_from_clock(filter);

  /****************************************************************************/
  /* now handle output data. */

  GST_DEBUG(0, "--- done with clock, going to output");

  data_out = (_TYPE_ *) GST_BUFFER_DATA(out);
  num_out = GST_BUFFER_SIZE(out) / sizeof(_TYPE_);

  for (k = 0; k < num_out; k++) {
    data_out[k] = zero;
  }

  /* output play pointer data. */
  for (t = 0; t < GST_POD_MAX_PLAY_PTRS; t++) {
    offset = filter->plays[t];

    if (offset != G_MAXUINT) {
      if (! filter->play_from_beginning) {
        for (k = 0; k < num_out; k++) {
          data_out[k] = CLAMP(data_out[k] + filter_data[(offset + k) % num_filter], min, max);
        }
      } else {
        for (k = 0; (k < num_out) && (k < (w + j - offset)); k++) {
          data_out[k] = CLAMP(data_out[k] + filter_data[offset + k], min, max);
        }
      }

      if ((! filter->play_from_beginning) || ((offset + k) < (w + j))) {
        filter->plays[t] = (offset + k) % num_filter;
      } else {
        filter->plays[t] = G_MAXUINT;
      }
    }
  }

  /****************************************************************************/
  /* push out the buffer. */

  GST_DEBUG(0, "--- done with output, pushing buffer %p", out);

  gst_pad_push(filter->srcpad, out);

  if (! filter->eos) {
    in = gst_pad_pull(filter->sinkpad);
  }

  gst_element_yield (GST_ELEMENT (filter));

} while (TRUE);
