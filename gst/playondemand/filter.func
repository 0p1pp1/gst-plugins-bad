/* -*- C -*- */

_TYPE_ *data_in, *data_out, *filter_data;

filter_data = (_TYPE_ *) filter->buffer;
num_filter = filter->buffer_bytes / sizeof(_TYPE_);

/******************************************************************************/
/* see if we've got any events coming through ... */

do {
  while (GST_IS_EVENT(in)) {
    if (GST_EVENT_TYPE(in) == GST_EVENT_EOS) {
      filter->eos = TRUE;
    } else if ((GST_EVENT_TYPE(in) == GST_EVENT_SEEK) ||
               (GST_EVENT_TYPE(in) == GST_EVENT_FLUSH)) {
      filter->eos = FALSE;
      filter->write = 0;
    } else {
      gst_pad_push(filter->srcpad, in);
    }

    in = gst_pad_pull(filter->sinkpad);
  }

  /****************************************************************************/
  /* first handle data from the input buffer. */

  /* only update the input if there hasn't been an eos yet. */
  if (! filter->eos) {
    data_in = (_TYPE_ *) GST_BUFFER_DATA(in);
    num_in = GST_BUFFER_SIZE(in) / sizeof(_TYPE_);

    w = filter->write;

    /* copy the input data to the filter's internal buffer. */
    for (j = 0; (j < num_in) && ((w + j) < num_filter); j++)
      filter_data[(w + j) % num_filter] = data_in[j];

    filter->write = (w + j) % num_filter;

    if ((w + j) >= num_filter)
      filter->eos = TRUE;

    out = in;
  } else {
    j = num_filter;
    w = 0;

    out = gst_buffer_new_from_pool(filter->bufpool, 0, 0);
  }

  /****************************************************************************/
  /* check to see if we have to add a new play pointer. */

  if (filter->clock) {
    current_tick = ((guint) (gst_clock_get_time(filter->clock) *
                             filter->clock_speed)) % filter->total_ticks;

    if (current_tick != last_tick) {
      /* now we go through the tick list and play samples */
      tick_list = filter->tick_list;
      while (tick_list) {
        tick = GPOINTER_TO_UINT(tick_list->data);
        if (current_tick == tick)
          play_on_demand_add_play_pointer(filter, 0);
        else if (GST_POD_TICK_ELAPSED(tick, current_tick, last_tick))
          play_on_demand_add_play_pointer(filter, GST_POD_SAMPLE_OFFSET(filter, current_tick - tick));
        tick_list = g_slist_next(tick_list);
      }
      last_tick = current_tick;
    }
  }

  /****************************************************************************/
  /* now handle output data. */

  data_out = (_TYPE_ *) GST_BUFFER_DATA(out);
  num_out = GST_BUFFER_SIZE(out) / sizeof(_TYPE_);

  for (k = 0; k < num_out; k++)
    data_out[k] = zero;

  /* output play pointer data. */
  if (! filter->mute)
    for (t = 0; t < filter->max_plays; t++) {
      offset = filter->plays[t];

      if (offset != G_MAXUINT) {
        for (k = 0; (k < num_out) && (offset + k < num_filter); k++)
          data_out[k] = CLAMP(data_out[k] + filter_data[offset + k], min, max);

        if ((offset + k) == num_filter)
          filter->plays[t] = G_MAXUINT;
        else
          filter->plays[t] = offset + k;
      }
    }

  /****************************************************************************/
  /* push out the buffer. */

  gst_pad_push(filter->srcpad, out);

  if (! filter->eos)
    in = gst_pad_pull(filter->sinkpad);

  gst_element_interrupt (GST_ELEMENT (filter));

} while (TRUE);
